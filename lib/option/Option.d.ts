export declare class Option<T> {
    static some<T>(value: T): Option<T>;
    static none<T>(): Option<T>;
    static from<T>(value?: T | null): Option<T>;
    private _value;
    constructor(createSecret: unknown, value: T);
    isNone(): boolean;
    isSome(): boolean;
    expect(msg: (() => string) | string): T;
    unwrap(): T;
    unwrapOr(def: T): T;
    unwrapOrElse(defFn: () => T): T;
    map<U>(fn: (value: T) => U): Option<U>;
    mapOr<U>(fn: (value: T) => U, def: U): Option<U>;
    mapOrElse<U>(fn: (value: T) => U, defFn: () => U): Option<U>;
    flatMap<U>(fn: (value: T) => Option<U>): Option<U>;
    flatMapOr<U>(fn: (value: T) => Option<U>, def: Option<U>): Option<U>;
    flatMapOrElse<U>(fn: (value: T) => Option<U>, defFn: () => Option<U>): Option<U>;
    and<U>(value: Option<U>): Option<U>;
    andThen<U>(fn: (value: T) => Option<U>): Option<U>;
    or(value: Option<T>): Option<T>;
    orElse(fn: () => Option<T>): Option<T>;
    xor(value: Option<T>): Option<T>;
    filter<S extends T>(fn: (value: T) => value is S): Option<S>;
    filter(fn: (value: T) => boolean): Option<T>;
    getOrInsert(value: T): Option<T>;
    getOrInsertWith(fn: () => T): Option<T>;
    take(): Option<T>;
    from(value?: T | null): Option<T>;
    replace(value: T): Option<T>;
    clear(): Option<T>;
    okOr<E>(error: E): Result<T, E>;
    okOrElse<E>(errorFn: () => E): Result<T, E>;
    ifSome(fn: (value: T) => void, elseFn?: () => void): Option<T>;
    ifNone(fn: () => void, elseFn?: (value: T) => void): Option<T>;
    fromJSON(json: T | null): Option<T>;
    toJSON(): T | null;
    toJS(): T | null;
}
export declare const some: <T>(value: T) => Option<T>;
export declare const none: <T>() => Option<T>;
import { Result } from "../result";
