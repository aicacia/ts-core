function t(t,r){return t[0]=(4278190080&r)>>24,t[1]=(16711680&r)>>16,t[2]=(65280&r)>>8,t[3]=255&r,t}const r=new Uint8Array(1),e=new Uint8Array(4);class n{writeByte(t){return r[0]=t,this.write(r)}writeInteger(r){return this.write(t(e,r))}}class s extends n{constructor(){super(...arguments),this.hash=0}finish(){return this.hash}write(t){let r=this.hash;for(let e=0,n=t.length;e<n;e++)r=31*r+t[e];var e;return this.hash=(e=r)>>>1&1073741824|3221225471&e,this}}function i(){return new s}function o(t){return t[3]|t[2]<<8|t[1]<<16|t[0]<<24}const u=new Set;function h(t,r=i){return a(t,r()).finish()}function a(t,r){return p(t,r),u.clear(),r}function p(t,r){return null==t||u.has(t)||(u.add(t),"string"==typeof t?c(t,r):"number"==typeof t?function(t,r){r.writeInteger(t)}(t,r):"boolean"==typeof t?function(t,r){r.writeInteger(!0===t?1:0)}(t,r):"symbol"==typeof t?function(t,r){c(t.toString(),r)}(t,r):"function"==typeof t[Symbol.iterator]?function(t,r){for(const e of t)p(e,r)}(t,r):"number"==typeof t.length?function(t,r){for(let e=0,n=t.length;e<n;e++)p(t[e],r)}(t,r):function(t,r){for(const e in t)t.hasOwnProperty(e)&&(c(e,r),p(t[e],r))}(t,r)),r}function c(t,r){for(const e of t)r.writeInteger(e.charCodeAt(0))}function l(t){return null!=t&&"function"==typeof t.toJS?t.toJS():t}function f(t){return null!=t&&"function"==typeof t.toJSON?t.toJSON():t}const d={},_={};class x{constructor(t,r){if(t!==d)throw new TypeError("Options can only be created with the some or none functions");this._value=r}static some(t){return w(t)}static none(){return k()}static from(t){return null!=t?w(t):k()}static fromResult(t){return t.isOk()?w(t.unwrap()):k()}isNone(){return this._value===_}isSome(){return!this.isNone()}expect(t){if(this.isSome())return this._value;throw new Error("function"==typeof t?t():t)}unwrap(){return this.expect("Tried to unwrap value of none Option")}unwrapOr(t){return this.isSome()?this._value:t}unwrapOrElse(t){return this.isSome()?this._value:t()}map(t){return this.isSome()?w(t(this._value)):k()}mapOr(t,r){return this.isSome()?w(t(this._value)):w(r)}mapOrElse(t,r){return this.isSome()?w(t(this._value)):w(r())}flatMap(t){return this.isSome()?t(this._value):k()}flatMapOr(t,r){return this.isSome()?t(this._value):r}flatMapOrElse(t,r){return this.isSome()?t(this._value):r()}and(t){return this.isSome()?t:k()}andThen(t){return this.isSome()?t(this._value):k()}or(t){return this.isNone()?t:this}orElse(t){return this.isNone()?t():this}xor(t){const r=this.isSome(),e=t.isSome();return r&&!e?this:!r&&e?t:k()}filter(t){return this.isSome()&&t(this._value)?this:k()}getOrInsert(t){return this.isNone()&&(this._value=t),this}getOrInsertWith(t){return this.isNone()&&(this._value=t()),this}take(){if(this.isSome()){const t=this._value;return this._value=_,w(t)}return k()}from(t){return null!=t?this._value=t:this.clear(),this}replace(t){return this._value=t,this}clear(){return this._value=_,this}fromResult(t){return t.isOk()?w(t.unwrap()):k()}ifSome(t,r){return this.isSome()?t(this._value):r&&r(),this}ifNone(t,r){return this.isNone()?t():r&&r(this._value),this}fromJSON(t){return x.from(t)}toJSON(){return this.map(f).unwrapOr(null)}toJS(){return this.map(l).unwrapOr(null)}}const w=t=>new x(d,t),k=()=>new x(d,_);class m{constructor(t){this._index=0,this._iter=t}[Symbol.iterator](){return this}iter(){return this}next(){return this._iter.next()}nextWithIndex(){const t=this._iter.next();return t.done?t:{value:[t.value,this._index++]}}enumerate(){}peekable(){}forEach(t){}map(t){}merge(t){}concat(t){return this.merge(t)}filter(t){}step(t){}skip(t){}take(t){}toMap(t,r){}count(){return this.reduce(0,(t=>t+1))}consume(){let t=this.next();for(;!t.done;)t=this.next();return this}toArray(){return this.reduce([],((t,r)=>(t.push(r),t)))}join(t){return this.toArray().join(t)}indexOf(t){let r=this.next(),e=0;for(;!r.done;){if(r.value===t)return e;e++,r=this.next()}return-1}findIndex(t){let r=this.nextWithIndex();for(;!r.done;){const[e,n]=r.value;if(t(e,n))return n;r=this.nextWithIndex()}return-1}find(t){let r=this.nextWithIndex();for(;!r.done;){const[e,n]=r.value;if(t(e,n))return w(e);r=this.nextWithIndex()}return k()}findAll(t){return this.filter(t)}nth(t=0){let r=this.next();for(t<0&&(t=0);!r.done;){if(t--<=0)return w(r.value);r=this.next()}return k()}first(){return this.nth(0)}last(){let t=this.next();for(;!t.done;){const r=this.next();if(r.done)return w(t.value);t=r}return k()}any(t){return-1!==this.findIndex(t)}some(t){return this.any(t)}none(t){return-1===this.findIndex(t)}all(t){let r=this.nextWithIndex();for(;!r.done;){const[e,n]=r.value;if(!t(e,n))return!1;r=this.nextWithIndex()}return!0}unflatten(t){}reduce(t,r){let e=this.next();for(;!e.done;){t=r(t,e.value,this._index-1),e=this.next()}return t}reverse(){return v(this.toArray().reverse())}}function v(t){return null!=t?"function"==typeof t[Symbol.iterator]?new m(t[Symbol.iterator]()):"function"==typeof t.next?t instanceof m?t:new m(t):v("object"==typeof t?Object.entries(t):[t]):v([])}class O extends m{constructor(t){super(t)}next(){const t=super.nextWithIndex();return t.done?t:{value:E(t.value)}}}function E(t){const r=t[0],e=t;return e[0]=t[1],e[1]=r,e}m.prototype.enumerate=function(){return new O(this)};class y extends m{constructor(t,r){super(t),this._fn=r}next(){let t=super.nextWithIndex();for(;!t.done;){const[r,e]=t.value;if(this._fn(r,e))return{done:!1,value:r};t=super.nextWithIndex()}return{done:!0,value:void 0}}}m.prototype.filter=function(t){return new y(this,t)};class S extends m{constructor(t,r){super(t),this._fn=([t,e])=>(r(t,e),t)}next(){const t=super.nextWithIndex();return t.done?t:{done:!1,value:this._fn(t.value)}}}m.prototype.forEach=function(t){return new S(this,t)};class I extends m{constructor(t,r){super(t),this._fn=([t,e])=>r(t,e)}next(){const t=super.nextWithIndex();return t.done?t:{done:!1,value:this._fn(t.value)}}}m.prototype.map=function(t){return new I(this,t)};class g extends m{constructor(t,r){super(t),this._other=r}next(){const t=super.next();return t.done?this._other.next():t}}m.prototype.merge=function(t){return new g(this,t)};class b extends m{constructor(){super(...arguments),this.peeked=[]}unpeekAll(){return this.peeked.length=0,this}unpeek(){return this.peeked.length>0?w(this.peeked.shift()):k()}peek(t=0){if(t<this.peeked.length)return w(this.peeked[t]);{let r=this.peeked.length-t-1,e=super.next();for(;!(e.done||(this.peeked.push(e.value),--r<=0));)e=super.next();return e.done?k():w(e.value)}}next(){const t=this.unpeek();if(t.isSome())return{done:!1,value:t.unwrap()};const r=super.next();return r.done?r:{done:!1,value:r.value}}}m.prototype.peekable=function(){return new b(this)};class N extends m{constructor(t,r){super(t),this._skipped=0,this._skip=0|(r<=0?0:r)}next(){let t=super.next();for(;!t.done;){if(!(this._skipped<=this._skip))return t;this._skipped+=1,t=super.next()}return{done:!0,value:void 0}}}m.prototype.skip=function(t){return new N(this,t)};class W extends m{constructor(t,r){super(t),this._stepped=0,this._step=r<=0?1:0|r}next(){let t=super.next();for(;!t.done;){if(!(this._stepped<this._step))return this._stepped=0,t;this._stepped+=1,t=super.next()}return{done:!0,value:void 0}}}m.prototype.step=function(t){return new W(this,t)};class M extends m{constructor(t,r){super(t),this._taken=0,this._count=0|(r<=0?0:r)}next(){return this._taken<this._count?(this._taken+=1,super.next()):{done:!0,value:void 0}}}m.prototype.take=function(t){return new M(this,t)};const J=t=>t,A=t=>t;class F extends m{constructor(t,r=J,e=A){super(t),this._map=([t,n])=>[r(t,n),e(t,n)]}toObject(){return this.reduce({},((t,r)=>(t[r[0]]=r[1],t)))}next(){const t=super.nextWithIndex();return t.done?t:{done:!1,value:this._map(t.value)}}}m.prototype.toMap=function(t,r){return new F(this,t,r)};class T extends m{constructor(t,r){super(t),this._fn=r}next(){return this._fn(this._iter)}}var j;m.prototype.unflatten=function(t){return new T(this,t)},function(t){t[t.Forward=0]="Forward",t[t.Backward=1]="Backward"}(j||(j={}));class R{constructor(t,r,e=1){this.start=t,this.end=r,this.step=Math.abs(e),this.direction=t>r?j.Backward:j.Forward}static from(t,r,e=1){return new R(t,r,e)}getStart(){return this.start}getEnd(){return this.end}getStep(){return this.step}getDirection(){return this.direction}contains(t){return this.start<=t&&t<=this.end}isEmpty(){return this.direction===j.Forward?this.start>this.end:this.start<this.end}iter(){return new m(this)}[Symbol.iterator](){return this}next(){if(this.isEmpty())return{done:!0,value:void 0};{const t=this.start;return this.direction===j.Forward?this.start+=this.step:this.start-=this.step,{done:!1,value:t}}}}const B=R.from;class U extends R{static from(t,r=j.Forward,e=1){return new U(t,r,e)}constructor(t,r=j.Forward,e=1){r===j.Forward?super(t,1/0,e):super(t,-1/0,e)}}const C=U.from,D={},P={};class q{constructor(t,r,e){if(t!==D)throw new TypeError("Results can only be created with the ok or err functions");this._ok=r,this._err=e}static ok(t){return z(t)}static err(t){return G(t)}static fromOption(t,r="Tried to create Result from none Option"){return t.isSome()?z(t.unwrap()):G(new Error(r))}isErr(){return this._err!==P}isOk(){return this._ok!==P}expect(){if(this.isOk())return this._ok;throw this._err}unwrap(){return this.expect()}unwrapOr(t){return this.isOk()?this._ok:t}unwrapOrElse(t){return this.isOk()?this._ok:t(this._err)}map(t){return this.isOk()?z(t(this._ok)):G(this._err)}mapOr(t,r){return this.isOk()?z(t(this._ok)):z(r)}mapOrElse(t,r){return this.isOk()?z(t(this._ok)):z(r(this._err))}flatMap(t){return this.isOk()?t(this._ok):G(this._err)}flatMapOr(t,r){return this.isOk()?t(this._ok):r}flatMapOrElse(t,r){return this.isOk()?t(this._ok):r(this._err)}expectErr(t){if(this.isErr())return this._err;throw new Error("function"==typeof t?t():t)}unwrapErr(){return this.expectErr("Tried to unwrap error value of ok Result")}unwrapErrOr(t){return this.isErr()?this._err:t}unwrapErrOrElse(t){return this.isErr()?this._err:t(this._ok)}mapErr(t){return this.isErr()?G(t(this._err)):z(this._ok)}mapErrOr(t,r){return this.isErr()?G(t(this._err)):G(r)}mapErrOrElse(t,r){return this.isErr()?G(t(this._err)):G(r(this._ok))}flatMapErr(t){return this.isErr()?t(this._err):z(this._ok)}flatMapErrOr(t,r){return this.isErr()?t(this._err):r}flatMapErrOrElse(t,r){return this.isErr()?t(this._err):r(this._ok)}and(t){return this.isOk()?t:G(this._err)}andThen(t){return this.isOk()?t(this._ok):G(this._err)}or(t){return this.isErr()?t:this}orElse(t){return this.isErr()?t(this._err):this}ifOk(t,r){return this.isOk()?t(this._ok):r&&r(this._err),this}ifErr(t,r){return this.isErr()?t(this._err):r&&r(this._ok),this}fromJSON(t){if(t){if(t.ok)return z(t.ok);if(t.err)return G(t.err)}throw new TypeError("Invalid json for Result")}toJSON(){return this.isOk()?{ok:this.map(f).unwrap()}:{err:this.mapErr(f).unwrapErr()}}toJS(){return this.isOk()?{ok:this.map(l).unwrap()}:{err:this.mapErr(l).unwrapErr()}}}const z=t=>new q(D,t,P),G=t=>new q(D,P,t);export{O as Enumerate,s as FastHasher,y as Filter,S as ForEach,n as Hasher,m as Iter,I as Map,g as Merge,x as Option,b as Peekable,R as Range,j as RangeDirection,U as RangeFrom,q as Result,N as Skip,W as Step,M as Take,F as ToMap,T as Unflatten,o as bytesToInteger,i as defaultHasher,G as err,a as hash,h as hashOf,t as integerToBytes,v as iter,k as none,z as ok,B as range,C as rangeFrom,w as some,l as toJS,f as toJSON};
//# sourceMappingURL=index.mjs.map
