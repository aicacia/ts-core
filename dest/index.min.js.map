{"version":3,"file":"index.min.js","sources":["../src/hash/integerToBytes.ts","../src/hash/Hasher.ts","../src/hash/FastHasher.ts","../src/hash/smi.ts","../src/hash/defaultHasher.ts","../src/hash/hash.ts","../src/toJS.ts","../src/toJSON.ts","../src/option/Option.ts","../src/iter/Iter.ts","../src/iter/Enumerate.ts","../src/iter/Filter.ts","../src/iter/ForEach.ts","../src/iter/Map.ts","../src/iter/Merge.ts","../src/iter/Peekable.ts","../src/iter/Skip.ts","../src/iter/Step.ts","../src/iter/Take.ts","../src/iter/ToMap.ts","../src/iter/Unflatten.ts","../src/range/Range.ts","../src/range/RangeFrom.ts","../src/result/Result.ts","../src/hash/bytesToInteger.ts"],"sourcesContent":["export function integerToBytes<\n  B extends Uint8Array | [number, number, number, number] =\n    | Uint8Array\n    | [number, number, number, number]\n>(bytes: B, integer: number): B {\n  bytes[0] = (integer & 0xff000000) >> 24;\n  bytes[1] = (integer & 0x00ff0000) >> 16;\n  bytes[2] = (integer & 0x0000ff00) >> 8;\n  bytes[3] = integer & 0x000000ff;\n  return bytes;\n}\n","import { integerToBytes } from \"./integerToBytes\";\n\nconst BYTE_ARRAY = new Uint8Array(1),\n  INTEGER_ARRAY = new Uint8Array(4);\n\nexport abstract class Hasher {\n  abstract finish(): number;\n  abstract write<B extends Uint8Array | number[] = Uint8Array | number[]>(\n    bytes: B\n  ): this;\n\n  writeByte(byte: number) {\n    BYTE_ARRAY[0] = byte;\n    return this.write(BYTE_ARRAY);\n  }\n  writeInteger(integer: number) {\n    return this.write(integerToBytes(INTEGER_ARRAY, integer));\n  }\n}\n","import { Hasher } from \"./Hasher\";\nimport { smi } from \"./smi\";\n\nexport class FastHasher extends Hasher {\n  private hash = 0;\n\n  finish() {\n    return this.hash;\n  }\n  write(bytes: Uint8Array | number[]) {\n    let hash = this.hash;\n    for (let i = 0, il = bytes.length; i < il; i++) {\n      hash = 31 * hash + bytes[i];\n    }\n    this.hash = smi(hash);\n    return this;\n  }\n}\n","// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nexport function smi(i32: number): number {\n  return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n}\n","import type { Hasher } from \"./Hasher\";\nimport { FastHasher } from \"./FastHasher\";\n\nexport function defaultHasher(): Hasher {\n  return new FastHasher();\n}\n","import type { Hasher } from \"./Hasher\";\nimport { defaultHasher } from \"./defaultHasher\";\n\nconst ALREADY_HASHED_SET = new Set<any>();\n\nexport function hashOf(\n  value: any,\n  getHasher: () => Hasher = defaultHasher\n): number {\n  return hash(value, getHasher()).finish();\n}\n\nexport function hash<H extends Hasher = Hasher>(value: any, hasher: H): H {\n  hashInternal(value, hasher);\n  ALREADY_HASHED_SET.clear();\n  return hasher;\n}\n\nfunction hashInternal<H extends Hasher = Hasher>(value: any, hasher: H): H {\n  if (value != null && !ALREADY_HASHED_SET.has(value)) {\n    ALREADY_HASHED_SET.add(value);\n\n    if (typeof value === \"string\") {\n      hashString(value, hasher);\n    } else if (typeof value === \"number\") {\n      hashNumber(value, hasher);\n    } else if (typeof value === \"boolean\") {\n      hashBoolean(value, hasher);\n    } else if (typeof value === \"symbol\") {\n      hashSymbol(value, hasher);\n    } else if (typeof value[Symbol.iterator] === \"function\") {\n      hashIterable(value, hasher);\n    } else if (typeof value.length === \"number\") {\n      hashArray(value, hasher);\n    } else {\n      hashObject(value, hasher);\n    }\n  }\n  return hasher;\n}\n\nfunction hashString(value: string, hasher: Hasher) {\n  for (const char of value) {\n    hasher.writeInteger(char.charCodeAt(0));\n  }\n}\n\nfunction hashNumber(value: number, hasher: Hasher) {\n  hasher.writeInteger(value);\n}\n\nfunction hashBoolean(value: boolean, hasher: Hasher) {\n  hasher.writeInteger(value === true ? 1 : 0);\n}\n\nfunction hashSymbol(value: symbol, hasher: Hasher) {\n  hashString(value.toString(), hasher);\n}\n\nfunction hashIterable(iterable: Iterable<any>, hasher: Hasher) {\n  for (const value of iterable) {\n    hashInternal(value, hasher);\n  }\n}\n\nfunction hashArray(array: Array<any>, hasher: Hasher) {\n  for (let i = 0, il = array.length; i < il; i++) {\n    hashInternal(array[i], hasher);\n  }\n}\n\nfunction hashObject(value: any, hasher: Hasher) {\n  for (const key in value) {\n    if (value.hasOwnProperty(key)) {\n      hashString(key, hasher);\n      hashInternal(value[key], hasher);\n    }\n  }\n}\n","export function toJS(value: any) {\n  return value != null && typeof value.toJS === \"function\"\n    ? value.toJS()\n    : value;\n}\n","export function toJSON(value: any) {\n  return value != null && typeof value.toJSON === \"function\"\n    ? value.toJSON()\n    : value;\n}\n","import type { Result } from \"../result\";\nimport { toJS } from \"../toJS\";\nimport { toJSON } from \"../toJSON\";\n\nconst CREATE_SECRET = {},\n  NULL_SECRET = {};\n\nexport class Option<T> {\n  static some<T>(value: T): Option<T> {\n    return some(value);\n  }\n  static none<T>(): Option<T> {\n    return none();\n  }\n\n  static from<T>(value?: T | null): Option<T> {\n    if (value != null) {\n      return some(value);\n    } else {\n      return none();\n    }\n  }\n  static fromResult<T, E = Error>(result: Result<T, E>): Option<T> {\n    if (result.isOk()) {\n      return some(result.unwrap());\n    } else {\n      return none();\n    }\n  }\n\n  private _value: T;\n\n  constructor(createSecret: unknown, value: T) {\n    if (createSecret !== CREATE_SECRET) {\n      throw new TypeError(\n        \"Options can only be created with the some or none functions\"\n      );\n    }\n    this._value = value;\n  }\n\n  isNone(): boolean {\n    return this._value === NULL_SECRET;\n  }\n\n  isSome(): boolean {\n    return !this.isNone();\n  }\n\n  expect(msg: (() => string) | string): T {\n    if (this.isSome()) {\n      return this._value;\n    } else {\n      throw new Error(typeof msg === \"function\" ? msg() : msg);\n    }\n  }\n\n  unwrap(): T {\n    return this.expect(\"Tried to unwrap value of none Option\");\n  }\n  unwrapOr(def: T): T {\n    if (this.isSome()) {\n      return this._value;\n    } else {\n      return def;\n    }\n  }\n  unwrapOrElse(defFn: () => T): T {\n    if (this.isSome()) {\n      return this._value;\n    } else {\n      return defFn();\n    }\n  }\n\n  map<U>(fn: (value: T) => U): Option<U> {\n    if (this.isSome()) {\n      return some(fn(this._value));\n    } else {\n      return none();\n    }\n  }\n  mapOr<U>(fn: (value: T) => U, def: U): Option<U> {\n    if (this.isSome()) {\n      return some(fn(this._value));\n    } else {\n      return some(def);\n    }\n  }\n  mapOrElse<U>(fn: (value: T) => U, defFn: () => U): Option<U> {\n    if (this.isSome()) {\n      return some(fn(this._value));\n    } else {\n      return some(defFn());\n    }\n  }\n\n  flatMap<U>(fn: (value: T) => Option<U>): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return none();\n    }\n  }\n  flatMapOr<U>(fn: (value: T) => Option<U>, def: Option<U>): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return def;\n    }\n  }\n  flatMapOrElse<U>(\n    fn: (value: T) => Option<U>,\n    defFn: () => Option<U>\n  ): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return defFn();\n    }\n  }\n\n  and<U>(value: Option<U>): Option<U> {\n    if (this.isSome()) {\n      return value;\n    } else {\n      return none();\n    }\n  }\n  andThen<U>(fn: (value: T) => Option<U>): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return none();\n    }\n  }\n\n  or(value: Option<T>): Option<T> {\n    if (this.isNone()) {\n      return value;\n    } else {\n      return this;\n    }\n  }\n  orElse(fn: () => Option<T>): Option<T> {\n    if (this.isNone()) {\n      return fn();\n    } else {\n      return this;\n    }\n  }\n\n  xor(value: Option<T>): Option<T> {\n    const a = this.isSome(),\n      b = value.isSome();\n\n    if (a && !b) {\n      return this;\n    } else if (!a && b) {\n      return value;\n    } else {\n      return none();\n    }\n  }\n\n  filter<S extends T>(fn: (value: T) => value is S): Option<S>;\n  filter(fn: (value: T) => boolean): Option<T>;\n  filter(fn: any): any {\n    if (this.isSome() && fn(this._value)) {\n      return this;\n    } else {\n      return none();\n    }\n  }\n\n  getOrInsert(value: T): Option<T> {\n    if (this.isNone()) {\n      this._value = value;\n    }\n    return this;\n  }\n  getOrInsertWith(fn: () => T): Option<T> {\n    if (this.isNone()) {\n      this._value = fn();\n    }\n    return this;\n  }\n\n  take(): Option<T> {\n    if (this.isSome()) {\n      const value = this._value;\n      this._value = NULL_SECRET as any;\n      return some(value);\n    } else {\n      return none();\n    }\n  }\n  from(value?: T | null): Option<T> {\n    if (value != null) {\n      this._value = value;\n    } else {\n      this.clear();\n    }\n    return this;\n  }\n  replace(value: T): Option<T> {\n    this._value = value;\n    return this;\n  }\n  clear(): Option<T> {\n    this._value = NULL_SECRET as any;\n    return this;\n  }\n\n  fromResult<T, E>(result: Result<T, E>): Option<T> {\n    if (result.isOk()) {\n      return some(result.unwrap());\n    } else {\n      return none();\n    }\n  }\n\n  ifSome(fn: (value: T) => void, elseFn?: () => void): Option<T> {\n    if (this.isSome()) {\n      fn(this._value);\n    } else if (elseFn) {\n      elseFn();\n    }\n    return this;\n  }\n  ifNone(fn: () => void, elseFn?: (value: T) => void): Option<T> {\n    if (this.isNone()) {\n      fn();\n    } else if (elseFn) {\n      elseFn(this._value);\n    }\n    return this;\n  }\n\n  fromJSON(json: T | null): Option<T> {\n    return Option.from(json);\n  }\n  toJSON(): T | null {\n    return this.map(toJSON).unwrapOr(null as any);\n  }\n  toJS(): T | null {\n    return this.map(toJS).unwrapOr(null as any);\n  }\n}\n\nexport const some = <T>(value: T): Option<T> =>\n  new Option(CREATE_SECRET, value);\nexport const none = <T>(): Option<T> =>\n  new Option(CREATE_SECRET, NULL_SECRET as T);\n","import type { Option } from \"../option\";\nimport type { Filter, IFilterBooleanFn, IFilterPredicateFn } from \"./Filter\";\nimport type { ForEach, IForEachFn } from \"./ForEach\";\nimport type { IMapFn, Map } from \"./Map\";\nimport type { Merge } from \"./Merge\";\nimport type { Skip } from \"./Skip\";\nimport type { Step } from \"./Step\";\nimport type { Take } from \"./Take\";\nimport type { IToMapFn, ToMap } from \"./ToMap\";\nimport type { Unflatten, UnflattenFn } from \"./Unflatten\";\nimport type { Enumerate } from \"./Enumerate\";\nimport type { Peekable } from \"./Peekable\";\nimport { none, some } from \"../option\";\n\nexport class Iter<T>\n  implements\n    Iterable<T>,\n    Iterator<T, undefined, undefined>,\n    IterableIterator<T>\n{\n  protected _iter: Iterator<T>;\n  protected _index = 0;\n\n  constructor(iter: Iterator<T>) {\n    this._iter = iter;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this;\n  }\n\n  iter(): Iter<T> {\n    return this;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    return this._iter.next();\n  }\n\n  nextWithIndex(): IteratorResult<[T, number], undefined> {\n    const next = this._iter.next();\n\n    if (next.done) {\n      return next;\n    } else {\n      return { value: [next.value, this._index++] };\n    }\n  }\n\n  enumerate(): Enumerate<T>;\n  enumerate(): any {\n    return undefined;\n  }\n\n  peekable(): Peekable<T>;\n  peekable(): any {\n    return undefined;\n  }\n\n  forEach(fn: IForEachFn<T>): ForEach<T>;\n  forEach(_fn: any): any {\n    return undefined;\n  }\n\n  map<B>(fn: IMapFn<T, B>): Map<T, B>;\n  map(_fn: any): any {\n    return undefined;\n  }\n\n  merge(iter: Iterator<T>): Merge<T>;\n  merge(_iter: any): any {\n    return undefined;\n  }\n\n  concat(iter: Iterator<T>): Merge<T> {\n    return this.merge(iter);\n  }\n\n  filter<S extends T>(fn: IFilterPredicateFn<T, S>): Filter<T, S>;\n  filter(fn: IFilterBooleanFn<T>): Filter<T, T>;\n  filter(_fn: any): any {\n    return undefined;\n  }\n\n  step(step: number): Step<T>;\n  step(_step: any): any {\n    return undefined;\n  }\n\n  skip(skip: number): Skip<T>;\n  skip(_skip: any): any {\n    return undefined;\n  }\n\n  take(count: number): Take<T>;\n  take(_count: any): any {\n    return undefined;\n  }\n\n  toMap<K extends string | number | symbol, V>(\n    keyFn?: IToMapFn<T, K>,\n    valueFn?: IToMapFn<T, V>\n  ): ToMap<T, K, V>;\n  toMap(_keyFn: any, _valueFn: any): any {\n    return undefined;\n  }\n\n  count() {\n    return this.reduce(0, (count) => count + 1);\n  }\n\n  consume() {\n    let next = this.next();\n\n    while (!next.done) {\n      next = this.next();\n    }\n\n    return this;\n  }\n\n  toArray(): T[] {\n    return this.reduce<T[]>([], (array, value) => {\n      array.push(value);\n      return array;\n    });\n  }\n\n  join(separator?: string): string {\n    return this.toArray().join(separator);\n  }\n\n  indexOf(value: T): number {\n    let next = this.next(),\n      index = 0;\n\n    while (!next.done) {\n      if (next.value === value) {\n        return index;\n      }\n      index++;\n      next = this.next();\n    }\n\n    return -1;\n  }\n\n  findIndex(fn: (value: T, index: number) => boolean): number {\n    let next = this.nextWithIndex();\n\n    while (!next.done) {\n      const [value, index] = next.value;\n\n      if (fn(value, index)) {\n        return index;\n      }\n      next = this.nextWithIndex();\n    }\n\n    return -1;\n  }\n\n  find(fn: (value: T, index: number) => boolean): Option<T> {\n    let next = this.nextWithIndex();\n\n    while (!next.done) {\n      const [value, index] = next.value;\n\n      if (fn(value, index)) {\n        return some(value);\n      }\n      next = this.nextWithIndex();\n    }\n\n    return none();\n  }\n\n  findAll(fn: (value: T) => boolean) {\n    return this.filter(fn);\n  }\n\n  nth(index = 0): Option<T> {\n    let next = this.next();\n\n    if (index < 0) {\n      index = 0;\n    }\n\n    while (!next.done) {\n      if (index-- <= 0) {\n        return some(next.value);\n      }\n      next = this.next();\n    }\n\n    return none();\n  }\n\n  first(): Option<T> {\n    return this.nth(0);\n  }\n\n  last(): Option<T> {\n    let current = this.next();\n\n    while (!current.done) {\n      const next = this.next();\n\n      if (next.done) {\n        return some(current.value);\n      } else {\n        current = next;\n      }\n    }\n\n    return none();\n  }\n\n  any(fn: (value: T, index: number) => boolean): boolean {\n    return this.findIndex(fn) !== -1;\n  }\n  some(fn: (value: T, index: number) => boolean): boolean {\n    return this.any(fn);\n  }\n  none(fn: (value: T, index: number) => boolean): boolean {\n    return this.findIndex(fn) === -1;\n  }\n\n  all(fn: (value: T, index: number) => boolean): boolean {\n    let next = this.nextWithIndex();\n\n    while (!next.done) {\n      const [value, index] = next.value;\n\n      if (!fn(value, index)) {\n        return false;\n      }\n      next = this.nextWithIndex();\n    }\n\n    return true;\n  }\n\n  unflatten<U>(fn: UnflattenFn<T, U>): Unflatten<T, U>;\n  unflatten(_fn: any): any {\n    return undefined;\n  }\n\n  reduce<C>(acc: C, fn: (acc: C, value: T, index: number) => C): C {\n    let next = this.next();\n\n    while (!next.done) {\n      const value = next.value;\n      acc = fn(acc, value, this._index - 1);\n      next = this.next();\n    }\n\n    return acc;\n  }\n\n  reverse() {\n    return iter(this.toArray().reverse());\n  }\n}\n\nexport function iter<T>(\n  value: T[] | Iterator<T> | Iter<T> | Iterable<T>\n): Iter<T>;\nexport function iter<O>(\n  value: O | Iterable<[keyof O, O[keyof O]]>\n): Iter<[keyof O, O[keyof O]]>;\n\nexport function iter(value: any): Iter<any> {\n  if (value != null) {\n    if (typeof value[Symbol.iterator] === \"function\") {\n      return new Iter(value[Symbol.iterator]());\n    } else if (typeof value.next === \"function\") {\n      if (value instanceof Iter) {\n        return value;\n      } else {\n        return new Iter(value);\n      }\n    } else if (typeof value === \"object\") {\n      return iter(Object.entries(value));\n    } else {\n      return iter([value]);\n    }\n  } else {\n    return iter([] as any[]);\n  }\n}\n","import { Iter } from \"./Iter\";\n\nexport class Enumerate<T> extends Iter<[number, T]> {\n  constructor(iter: Iterator<T>) {\n    super(iter as any);\n  }\n\n  next(): IteratorResult<[number, T], undefined> {\n    const next: IteratorResult<[T, number], undefined> =\n      super.nextWithIndex() as any;\n\n    if (next.done) {\n      return next as any;\n    } else {\n      return { value: swap(next.value) };\n    }\n  }\n}\n\nIter.prototype.enumerate = function enumerate() {\n  return new Enumerate(this);\n};\n\nfunction swap<A, B>(array: [A, B]): [B, A] {\n  const tmp = array[0],\n    newArray: [B, A] = array as any;\n  newArray[0] = array[1];\n  newArray[1] = tmp;\n  return newArray;\n}\n","import { Iter } from \"./Iter\";\n\nexport type IFilterPredicateFn<T, S extends T> = (\n  value: T,\n  index: number\n) => value is S;\nexport type IFilterBooleanFn<T> = (value: T, index: number) => boolean;\n\nexport class Filter<T, S extends T> extends Iter<S> {\n  private _fn: IFilterBooleanFn<T> | IFilterPredicateFn<T, S>;\n\n  constructor(\n    iter: Iterator<T>,\n    fn: IFilterBooleanFn<T> | IFilterPredicateFn<T, S>\n  ) {\n    super(iter as any);\n    this._fn = fn;\n  }\n\n  next(): IteratorResult<S, undefined> {\n    let result = super.nextWithIndex();\n\n    while (!result.done) {\n      const [value, index] = result.value;\n\n      if (this._fn(value, index)) {\n        return { done: false, value };\n      }\n      result = super.nextWithIndex();\n    }\n\n    return { done: true, value: undefined };\n  }\n}\n\nIter.prototype.filter = function filter(fn: any): any {\n  return new Filter(this, fn);\n};\n","import { Iter } from \"./Iter\";\n\nexport type IForEachFn<T> = (value: T, index: number) => void;\n\nexport class ForEach<T> extends Iter<T> {\n  private _fn: (tuple: [value: T, index: number]) => T;\n\n  constructor(iter: Iterator<T>, fn: IForEachFn<T>) {\n    super(iter);\n    this._fn = ([value, index]) => {\n      fn(value, index);\n      return value;\n    };\n  }\n\n  next(): IteratorResult<T, undefined> {\n    const next = super.nextWithIndex();\n\n    if (next.done) {\n      return next;\n    } else {\n      return { done: false, value: this._fn(next.value) };\n    }\n  }\n}\n\nIter.prototype.forEach = function forEach(fn: any) {\n  return new ForEach(this, fn);\n};\n","import { Iter } from \"./Iter\";\n\nexport type IMapFn<A, B> = (value: A, index: number) => B;\n\nexport class Map<A, B> extends Iter<B> {\n  private _fn: (tuple: [value: A, index: number]) => B;\n\n  constructor(iter: Iterator<A>, fn: IMapFn<A, B>) {\n    super(iter as any as Iterator<B>);\n    this._fn = ([value, index]) => fn(value, index);\n  }\n\n  next(): IteratorResult<B, undefined> {\n    const next = super.nextWithIndex();\n\n    if (next.done) {\n      return next;\n    } else {\n      return { done: false, value: this._fn(next.value as any) };\n    }\n  }\n}\n\nIter.prototype.map = function map(fn: any) {\n  return new Map(this, fn);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Merge<T> extends Iter<T> {\n  private _other: Iterator<T>;\n\n  constructor(iter: Iterator<T>, other: Iterator<T>) {\n    super(iter);\n    this._other = other;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    const next = super.next();\n\n    if (next.done) {\n      return this._other.next();\n    } else {\n      return next;\n    }\n  }\n}\n\nIter.prototype.merge = function merge(other: any) {\n  return new Merge(this, other);\n};\n","import { Option, some, none } from \"../option\";\nimport { Iter } from \"./Iter\";\n\nexport class Peekable<T> extends Iter<T> {\n  private peeked: T[] = [];\n\n  unpeekAll() {\n    this.peeked.length = 0;\n    return this;\n  }\n\n  unpeek(): Option<T> {\n    if (this.peeked.length > 0) {\n      return some(this.peeked.shift() as T);\n    } else {\n      return none();\n    }\n  }\n\n  peek(offset = 0): Option<T> {\n    if (offset < this.peeked.length) {\n      return some(this.peeked[offset]);\n    } else {\n      let index = this.peeked.length - offset - 1,\n        next = super.next();\n\n      while (!next.done) {\n        this.peeked.push(next.value);\n\n        if (--index <= 0) {\n          break;\n        } else {\n          next = super.next();\n        }\n      }\n\n      if (next.done) {\n        return none();\n      } else {\n        return some(next.value);\n      }\n    }\n  }\n\n  next(): IteratorResult<T, undefined> {\n    const peeked = this.unpeek();\n\n    if (peeked.isSome()) {\n      return { done: false, value: peeked.unwrap() };\n    }\n\n    const next = super.next();\n\n    if (next.done) {\n      return next as any;\n    } else {\n      return { done: false, value: next.value };\n    }\n  }\n}\n\nIter.prototype.peekable = function peekable() {\n  return new Peekable(this);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Skip<T> extends Iter<T> {\n  private _skipped: number;\n  private _skip: number;\n\n  constructor(iter: Iterator<T>, skip: number) {\n    super(iter);\n    this._skipped = 0;\n    this._skip = (skip <= 0 ? 0 : skip) | 0;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    let result = super.next();\n\n    while (!result.done) {\n      if (this._skipped <= this._skip) {\n        this._skipped += 1;\n        result = super.next();\n      } else {\n        return result;\n      }\n    }\n\n    return { done: true, value: undefined };\n  }\n}\n\nIter.prototype.skip = function skip(skip: any) {\n  return new Skip(this, skip);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Step<T> extends Iter<T> {\n  private _stepped: number;\n  private _step: number;\n\n  constructor(iter: Iterator<T>, step: number) {\n    super(iter);\n    this._stepped = 0;\n    this._step = step <= 0 ? 1 : step | 0;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    let result = super.next();\n\n    while (!result.done) {\n      if (this._stepped < this._step) {\n        this._stepped += 1;\n        result = super.next();\n      } else {\n        this._stepped = 0;\n        return result;\n      }\n    }\n\n    return { done: true, value: undefined };\n  }\n}\n\nIter.prototype.step = function step(step: any) {\n  return new Step(this, step);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Take<T> extends Iter<T> {\n  private _taken: number;\n  private _count: number;\n\n  constructor(iter: Iterator<T>, count: number) {\n    super(iter);\n    this._taken = 0;\n    this._count = (count <= 0 ? 0 : count) | 0;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    if (this._taken < this._count) {\n      this._taken += 1;\n      return super.next();\n    } else {\n      return { done: true, value: undefined };\n    }\n  }\n}\n\nIter.prototype.take = function take(count: any) {\n  return new Take(this, count);\n};\n","import { Iter } from \"./Iter\";\n\nexport type IToMapFn<A, B> = (value: A, index: number) => B;\n\nconst defaultKeyFn = <A, B>(key: A): B => key as any;\nconst defaultValueFn = <A, B>(value: A): B => value as any;\n\nexport class ToMap<T, K extends string | number | symbol, V> extends Iter<\n  [K, V]\n> {\n  private _map: (tuple: [value: any, index: number]) => [K, V];\n\n  constructor(\n    iter: Iterator<T>,\n    keyFn: IToMapFn<T, K> = defaultKeyFn,\n    valueFn: IToMapFn<T, V> = defaultValueFn\n  ) {\n    super(iter as any as Iterator<[K, V]>);\n    this._map = ([value, index]) =>\n      [keyFn(value, index), valueFn(value, index)] as [K, V];\n  }\n\n  toObject(): Record<K, V> {\n    return this.reduce<Record<K, V>>({} as Record<K, V>, (object, value) => {\n      object[value[0]] = value[1];\n      return object;\n    });\n  }\n\n  next(): IteratorResult<[K, V], undefined> {\n    const next = super.nextWithIndex();\n\n    if (next.done) {\n      return next as any;\n    } else {\n      return { done: false, value: this._map(next.value) };\n    }\n  }\n}\n\nIter.prototype.toMap = function toMap(keyFn: any, valueFn: any) {\n  return new ToMap(this, keyFn, valueFn);\n};\n","import { Iter } from \"./Iter\";\n\nexport type UnflattenFn<T, U> = (iter: Iterator<T>) => IteratorResult<U>;\n\nexport class Unflatten<T, U> extends Iter<U> {\n  private _fn: UnflattenFn<T, U>;\n\n  constructor(iter: Iterator<T>, fn: UnflattenFn<T, U>) {\n    super(iter as any);\n    this._fn = fn;\n  }\n\n  next(): IteratorResult<U> {\n    return this._fn(this._iter as any);\n  }\n}\n\nIter.prototype.unflatten = function unflatten(fn: any) {\n  return new Unflatten(this, fn);\n};\n","import { Iter } from \"../iter\";\n\nexport enum RangeDirection {\n  Forward,\n  Backward,\n}\n\nexport class Range implements Iterator<number>, Iterable<number> {\n  static from(start: number, end: number, step = 1) {\n    return new Range(start, end, step);\n  }\n\n  private start: number;\n  private end: number;\n  private step: number;\n  private direction: RangeDirection;\n\n  constructor(start: number, end: number, step = 1) {\n    this.start = start;\n    this.end = end;\n    this.step = Math.abs(step);\n    this.direction =\n      start > end ? RangeDirection.Backward : RangeDirection.Forward;\n  }\n\n  getStart() {\n    return this.start;\n  }\n  getEnd() {\n    return this.end;\n  }\n  getStep() {\n    return this.step;\n  }\n  getDirection() {\n    return this.direction;\n  }\n\n  contains(item: number) {\n    return this.start <= item && item <= this.end;\n  }\n\n  isEmpty() {\n    if (this.direction === RangeDirection.Forward) {\n      return this.start > this.end;\n    } else {\n      return this.start < this.end;\n    }\n  }\n\n  iter(): Iter<number> {\n    return new Iter(this);\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  next(): IteratorResult<number> {\n    if (this.isEmpty()) {\n      return { done: true, value: undefined };\n    } else {\n      const value = this.start;\n      if (this.direction === RangeDirection.Forward) {\n        this.start += this.step;\n      } else {\n        this.start -= this.step;\n      }\n      return { done: false, value };\n    }\n  }\n}\n\nexport const range = Range.from;\n","import { Range, RangeDirection } from \"./Range\";\n\nexport class RangeFrom extends Range {\n  static from(\n    start: number,\n    direction: RangeDirection = RangeDirection.Forward,\n    step = 1\n  ) {\n    return new RangeFrom(start, direction, step);\n  }\n\n  constructor(\n    start: number,\n    direction: RangeDirection = RangeDirection.Forward,\n    step = 1\n  ) {\n    if (direction === RangeDirection.Forward) {\n      super(start, Infinity, step);\n    } else {\n      super(start, -Infinity, step);\n    }\n  }\n}\n\nexport const rangeFrom = RangeFrom.from;\n","import type { Option } from \"../option\";\nimport { toJS } from \"../toJS\";\nimport { toJSON } from \"../toJSON\";\n\nconst CREATE_SECRET = {},\n  NULL_SECRET = {};\n\nexport class Result<T, E = Error> {\n  static ok<T, E = Error>(value: T): Result<T, E> {\n    return ok(value);\n  }\n  static err<T, E = Error>(error: E): Result<T, E> {\n    return err(error);\n  }\n  static fromOption<T>(\n    option: Option<T>,\n    msg = \"Tried to create Result from none Option\"\n  ): Result<T, Error> {\n    if (option.isSome()) {\n      return ok(option.unwrap());\n    } else {\n      return err<T>(new Error(msg));\n    }\n  }\n\n  private _ok: T;\n  private _err: E;\n\n  constructor(createSecret: unknown, ok: T, err: E) {\n    if (createSecret !== CREATE_SECRET) {\n      throw new TypeError(\n        \"Results can only be created with the ok or err functions\"\n      );\n    }\n    this._ok = ok;\n    this._err = err;\n  }\n\n  isErr(): boolean {\n    return this._err !== NULL_SECRET;\n  }\n\n  isOk(): boolean {\n    return this._ok !== NULL_SECRET;\n  }\n\n  expect(): T {\n    if (this.isOk()) {\n      return this._ok;\n    } else {\n      throw this._err;\n    }\n  }\n\n  unwrap(): T {\n    return this.expect();\n  }\n  unwrapOr(def: T): T {\n    if (this.isOk()) {\n      return this._ok;\n    } else {\n      return def;\n    }\n  }\n  unwrapOrElse(defFn: (error: E) => T): T {\n    if (this.isOk()) {\n      return this._ok;\n    } else {\n      return defFn(this._err);\n    }\n  }\n\n  map<U>(fn: (ok: T) => U): Result<U, E> {\n    if (this.isOk()) {\n      return ok(fn(this._ok));\n    } else {\n      return err(this._err);\n    }\n  }\n  mapOr<U>(fn: (ok: T) => U, def: U): Result<U, E> {\n    if (this.isOk()) {\n      return ok(fn(this._ok));\n    } else {\n      return ok(def);\n    }\n  }\n  mapOrElse<U>(fn: (ok: T) => U, defFn: (error: E) => U): Result<U, E> {\n    if (this.isOk()) {\n      return ok(fn(this._ok));\n    } else {\n      return ok(defFn(this._err));\n    }\n  }\n\n  flatMap<U>(fn: (ok: T) => Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return err(this._err);\n    }\n  }\n  flatMapOr<U>(fn: (ok: T) => Result<U, E>, def: Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return def;\n    }\n  }\n  flatMapOrElse<U>(\n    fn: (ok: T) => Result<U, E>,\n    defFn: (error: E) => Result<U, E>\n  ): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return defFn(this._err);\n    }\n  }\n\n  expectErr(msg: (() => string) | string): E {\n    if (this.isErr()) {\n      return this._err;\n    } else {\n      throw new Error(typeof msg === \"function\" ? msg() : msg);\n    }\n  }\n\n  unwrapErr(): E {\n    return this.expectErr(\"Tried to unwrap error value of ok Result\");\n  }\n  unwrapErrOr(def: E): E {\n    if (this.isErr()) {\n      return this._err;\n    } else {\n      return def;\n    }\n  }\n  unwrapErrOrElse(defFn: (value: T) => E): E {\n    if (this.isErr()) {\n      return this._err;\n    } else {\n      return defFn(this._ok);\n    }\n  }\n\n  mapErr<U>(fn: (err: E) => U): Result<T, U> {\n    if (this.isErr()) {\n      return err(fn(this._err));\n    } else {\n      return ok(this._ok);\n    }\n  }\n  mapErrOr<U>(fn: (err: E) => U, def: U): Result<T, U> {\n    if (this.isErr()) {\n      return err(fn(this._err));\n    } else {\n      return err(def);\n    }\n  }\n  mapErrOrElse<U>(fn: (err: E) => U, defFn: (value: T) => U): Result<T, U> {\n    if (this.isErr()) {\n      return err(fn(this._err));\n    } else {\n      return err(defFn(this._ok));\n    }\n  }\n\n  flatMapErr<U>(fn: (err: E) => Result<T, U>): Result<T, U> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return ok(this._ok);\n    }\n  }\n  flatMapErrOr<U>(\n    fn: (err: E) => Result<T, U>,\n    def: Result<T, U>\n  ): Result<T, U> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return def;\n    }\n  }\n  flatMapErrOrElse<U>(\n    fn: (err: E) => Result<T, U>,\n    defFn: (value: T) => Result<T, U>\n  ): Result<T, U> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return defFn(this._ok);\n    }\n  }\n\n  and<U>(ok: Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return ok;\n    } else {\n      return err(this._err);\n    }\n  }\n  andThen<U>(fn: (value: T) => Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return err(this._err);\n    }\n  }\n\n  or(ok: Result<T, E>): Result<T, E> {\n    if (this.isErr()) {\n      return ok;\n    } else {\n      return this;\n    }\n  }\n  orElse(fn: (error: E) => Result<T, E>): Result<T, E> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return this;\n    }\n  }\n\n  ifOk(fn: (ok: T) => void, errFn?: (err: E) => void): Result<T, E> {\n    if (this.isOk()) {\n      fn(this._ok);\n    } else if (errFn) {\n      errFn(this._err);\n    }\n    return this;\n  }\n  ifErr(fn: (err: E) => void, okFn?: (ok: T) => void): Result<T, E> {\n    if (this.isErr()) {\n      fn(this._err);\n    } else if (okFn) {\n      okFn(this._ok);\n    }\n    return this;\n  }\n\n  fromJSON(json: any): Result<T, E> {\n    if (json) {\n      if (json.ok) {\n        return ok(json.ok);\n      } else if (json.err) {\n        return err(json.err);\n      }\n    }\n    throw new TypeError(\"Invalid json for Result\");\n  }\n  toJSON(): IResultOk<T> | IResultErr<E> {\n    if (this.isOk()) {\n      return {\n        ok: this.map(toJSON).unwrap(),\n      };\n    } else {\n      return {\n        err: this.mapErr(toJSON).unwrapErr(),\n      };\n    }\n  }\n  toJS(): IResultOk<T> | IResultErr<E> {\n    if (this.isOk()) {\n      return {\n        ok: this.map(toJS).unwrap(),\n      };\n    } else {\n      return {\n        err: this.mapErr(toJS).unwrapErr(),\n      };\n    }\n  }\n}\n\nexport interface IResultOk<T> {\n  ok: T;\n}\nexport interface IResultErr<E> {\n  err: E;\n}\n\nexport const ok = <T, E = Error>(value: T): Result<T, E> =>\n  new Result(CREATE_SECRET, value, NULL_SECRET as E);\nexport const err = <T, E = Error>(error: E): Result<T, E> =>\n  new Result(CREATE_SECRET, NULL_SECRET as T, error);\n","export function bytesToInteger<\n  B extends Uint8Array | [number, number, number, number] =\n    | Uint8Array\n    | [number, number, number, number]\n>(bytes: B): number {\n  return bytes[3] | (bytes[2] << 8) | (bytes[1] << 16) | (bytes[0] << 24);\n}\n"],"names":["integerToBytes","bytes","integer","BYTE_ARRAY","Uint8Array","INTEGER_ARRAY","Hasher","writeByte","byte","this","write","writeInteger","FastHasher","constructor","finish","hash","i","il","length","i32","defaultHasher","ALREADY_HASHED_SET","Set","value","hasher","hashInternal","clear","has","add","hashString","hashNumber","hashBoolean","toString","hashSymbol","Symbol","iterator","iterable","hashIterable","array","hashArray","key","hasOwnProperty","hashObject","char","charCodeAt","toJS","toJSON","CREATE_SECRET","NULL_SECRET","Option","createSecret","TypeError","_value","some","none","from","fromResult","result","isOk","unwrap","isNone","isSome","expect","msg","Error","unwrapOr","def","unwrapOrElse","defFn","map","fn","mapOr","mapOrElse","flatMap","flatMapOr","flatMapOrElse","and","andThen","or","orElse","xor","a","b","filter","getOrInsert","getOrInsertWith","take","replace","ifSome","elseFn","ifNone","fromJSON","json","Iter","iter","_iter","next","nextWithIndex","done","_index","enumerate","peekable","forEach","_fn","merge","concat","step","_step","skip","_skip","_count","toMap","_keyFn","_valueFn","count","reduce","consume","toArray","push","join","separator","indexOf","index","findIndex","find","findAll","nth","first","last","current","any","all","unflatten","acc","reverse","Object","entries","Enumerate","super","swap","tmp","newArray","prototype","Filter","undefined","ForEach","Map","Merge","other","_other","Peekable","unpeekAll","peeked","unpeek","shift","peek","offset","Skip","_skipped","Step","_stepped","Take","_taken","defaultKeyFn","defaultValueFn","ToMap","keyFn","valueFn","_map","toObject","object","Unflatten","RangeDirection","Range","start","end","Math","abs","direction","Backward","Forward","getStart","getEnd","getStep","getDirection","contains","item","isEmpty","range","RangeFrom","Infinity","rangeFrom","Result","ok","err","_ok","_err","error","fromOption","option","isErr","expectErr","unwrapErr","unwrapErrOr","unwrapErrOrElse","mapErr","mapErrOr","mapErrOrElse","flatMapErr","flatMapErrOr","flatMapErrOrElse","ifOk","errFn","ifErr","okFn","getHasher"],"mappings":"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"}