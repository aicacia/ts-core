{"version":3,"file":"index.mjs","sources":["../src/hash/integerToBytes.ts","../src/hash/Hasher.ts","../src/hash/FastHasher.ts","../src/hash/smi.ts","../src/hash/defaultHasher.ts","../src/hash/bytesToInteger.ts","../src/hash/hash.ts","../src/toJS.ts","../src/toJSON.ts","../src/option/Option.ts","../src/iter/Iter.ts","../src/iter/Enumerate.ts","../src/iter/Filter.ts","../src/iter/ForEach.ts","../src/iter/Map.ts","../src/iter/Merge.ts","../src/iter/Peekable.ts","../src/iter/Skip.ts","../src/iter/Step.ts","../src/iter/Take.ts","../src/iter/ToMap.ts","../src/iter/Unflatten.ts","../src/range/Range.ts","../src/range/RangeFrom.ts","../src/result/Result.ts"],"sourcesContent":["export function integerToBytes<\n  B extends Uint8Array | [number, number, number, number] =\n    | Uint8Array\n    | [number, number, number, number]\n>(bytes: B, integer: number): B {\n  bytes[0] = (integer & 0xff000000) >> 24;\n  bytes[1] = (integer & 0x00ff0000) >> 16;\n  bytes[2] = (integer & 0x0000ff00) >> 8;\n  bytes[3] = integer & 0x000000ff;\n  return bytes;\n}\n","import { integerToBytes } from \"./integerToBytes\";\n\nconst BYTE_ARRAY = new Uint8Array(1),\n  INTEGER_ARRAY = new Uint8Array(4);\n\nexport abstract class Hasher {\n  abstract finish(): number;\n  abstract write<B extends Uint8Array | number[] = Uint8Array | number[]>(\n    bytes: B\n  ): this;\n\n  writeByte(byte: number) {\n    BYTE_ARRAY[0] = byte;\n    return this.write(BYTE_ARRAY);\n  }\n  writeInteger(integer: number) {\n    return this.write(integerToBytes(INTEGER_ARRAY, integer));\n  }\n}\n","import { Hasher } from \"./Hasher\";\nimport { smi } from \"./smi\";\n\nexport class FastHasher extends Hasher {\n  private hash = 0;\n\n  finish() {\n    return this.hash;\n  }\n  write(bytes: Uint8Array | number[]) {\n    let hash = this.hash;\n    for (let i = 0, il = bytes.length; i < il; i++) {\n      hash = 31 * hash + bytes[i];\n    }\n    this.hash = smi(hash);\n    return this;\n  }\n}\n","// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nexport function smi(i32: number): number {\n  return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n}\n","import type { Hasher } from \"./Hasher\";\nimport { FastHasher } from \"./FastHasher\";\n\nexport function defaultHasher(): Hasher {\n  return new FastHasher();\n}\n","export function bytesToInteger<\n  B extends Uint8Array | [number, number, number, number] =\n    | Uint8Array\n    | [number, number, number, number]\n>(bytes: B): number {\n  return bytes[3] | (bytes[2] << 8) | (bytes[1] << 16) | (bytes[0] << 24);\n}\n","import type { Hasher } from \"./Hasher\";\nimport { defaultHasher } from \"./defaultHasher\";\n\nconst ALREADY_HASHED_SET = new Set<any>();\n\nexport function hashOf(\n  value: any,\n  getHasher: () => Hasher = defaultHasher\n): number {\n  return hash(value, getHasher()).finish();\n}\n\nexport function hash<H extends Hasher = Hasher>(value: any, hasher: H): H {\n  hashInternal(value, hasher);\n  ALREADY_HASHED_SET.clear();\n  return hasher;\n}\n\nfunction hashInternal<H extends Hasher = Hasher>(value: any, hasher: H): H {\n  if (value != null && !ALREADY_HASHED_SET.has(value)) {\n    ALREADY_HASHED_SET.add(value);\n\n    if (typeof value === \"string\") {\n      hashString(value, hasher);\n    } else if (typeof value === \"number\") {\n      hashNumber(value, hasher);\n    } else if (typeof value === \"boolean\") {\n      hashBoolean(value, hasher);\n    } else if (typeof value === \"symbol\") {\n      hashSymbol(value, hasher);\n    } else if (typeof value[Symbol.iterator] === \"function\") {\n      hashIterable(value, hasher);\n    } else if (typeof value.length === \"number\") {\n      hashArray(value, hasher);\n    } else {\n      hashObject(value, hasher);\n    }\n  }\n  return hasher;\n}\n\nfunction hashString(value: string, hasher: Hasher) {\n  for (const char of value) {\n    hasher.writeInteger(char.charCodeAt(0));\n  }\n}\n\nfunction hashNumber(value: number, hasher: Hasher) {\n  hasher.writeInteger(value);\n}\n\nfunction hashBoolean(value: boolean, hasher: Hasher) {\n  hasher.writeInteger(value === true ? 1 : 0);\n}\n\nfunction hashSymbol(value: symbol, hasher: Hasher) {\n  hashString(value.toString(), hasher);\n}\n\nfunction hashIterable(iterable: Iterable<any>, hasher: Hasher) {\n  for (const value of iterable) {\n    hashInternal(value, hasher);\n  }\n}\n\nfunction hashArray(array: Array<any>, hasher: Hasher) {\n  for (let i = 0, il = array.length; i < il; i++) {\n    hashInternal(array[i], hasher);\n  }\n}\n\nfunction hashObject(value: any, hasher: Hasher) {\n  for (const key in value) {\n    if (value.hasOwnProperty(key)) {\n      hashString(key, hasher);\n      hashInternal(value[key], hasher);\n    }\n  }\n}\n","export function toJS(value: any) {\n  return value != null && typeof value.toJS === \"function\"\n    ? value.toJS()\n    : value;\n}\n","export function toJSON(value: any) {\n  return value != null && typeof value.toJSON === \"function\"\n    ? value.toJSON()\n    : value;\n}\n","import type { Result } from \"../result\";\nimport { toJS } from \"../toJS\";\nimport { toJSON } from \"../toJSON\";\n\nconst CREATE_SECRET = {},\n  NULL_SECRET = {};\n\nexport class Option<T> {\n  static some<T>(value: T): Option<T> {\n    return some(value);\n  }\n  static none<T>(): Option<T> {\n    return none();\n  }\n\n  static from<T>(value?: T | null): Option<T> {\n    if (value != null) {\n      return some(value);\n    } else {\n      return none();\n    }\n  }\n  static fromResult<T, E = Error>(result: Result<T, E>): Option<T> {\n    if (result.isOk()) {\n      return some(result.unwrap());\n    } else {\n      return none();\n    }\n  }\n\n  private _value: T;\n\n  constructor(createSecret: unknown, value: T) {\n    if (createSecret !== CREATE_SECRET) {\n      throw new TypeError(\n        \"Options can only be created with the some or none functions\"\n      );\n    }\n    this._value = value;\n  }\n\n  isNone(): boolean {\n    return this._value === NULL_SECRET;\n  }\n\n  isSome(): boolean {\n    return !this.isNone();\n  }\n\n  expect(msg: (() => string) | string): T {\n    if (this.isSome()) {\n      return this._value;\n    } else {\n      throw new Error(typeof msg === \"function\" ? msg() : msg);\n    }\n  }\n\n  unwrap(): T {\n    return this.expect(\"Tried to unwrap value of none Option\");\n  }\n  unwrapOr(def: T): T {\n    if (this.isSome()) {\n      return this._value;\n    } else {\n      return def;\n    }\n  }\n  unwrapOrElse(defFn: () => T): T {\n    if (this.isSome()) {\n      return this._value;\n    } else {\n      return defFn();\n    }\n  }\n\n  map<U>(fn: (value: T) => U): Option<U> {\n    if (this.isSome()) {\n      return some(fn(this._value));\n    } else {\n      return none();\n    }\n  }\n  mapOr<U>(fn: (value: T) => U, def: U): Option<U> {\n    if (this.isSome()) {\n      return some(fn(this._value));\n    } else {\n      return some(def);\n    }\n  }\n  mapOrElse<U>(fn: (value: T) => U, defFn: () => U): Option<U> {\n    if (this.isSome()) {\n      return some(fn(this._value));\n    } else {\n      return some(defFn());\n    }\n  }\n\n  flatMap<U>(fn: (value: T) => Option<U>): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return none();\n    }\n  }\n  flatMapOr<U>(fn: (value: T) => Option<U>, def: Option<U>): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return def;\n    }\n  }\n  flatMapOrElse<U>(\n    fn: (value: T) => Option<U>,\n    defFn: () => Option<U>\n  ): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return defFn();\n    }\n  }\n\n  and<U>(value: Option<U>): Option<U> {\n    if (this.isSome()) {\n      return value;\n    } else {\n      return none();\n    }\n  }\n  andThen<U>(fn: (value: T) => Option<U>): Option<U> {\n    if (this.isSome()) {\n      return fn(this._value);\n    } else {\n      return none();\n    }\n  }\n\n  or(value: Option<T>): Option<T> {\n    if (this.isNone()) {\n      return value;\n    } else {\n      return this;\n    }\n  }\n  orElse(fn: () => Option<T>): Option<T> {\n    if (this.isNone()) {\n      return fn();\n    } else {\n      return this;\n    }\n  }\n\n  xor(value: Option<T>): Option<T> {\n    const a = this.isSome(),\n      b = value.isSome();\n\n    if (a && !b) {\n      return this;\n    } else if (!a && b) {\n      return value;\n    } else {\n      return none();\n    }\n  }\n\n  filter<S extends T>(fn: (value: T) => value is S): Option<S>;\n  filter(fn: (value: T) => boolean): Option<T>;\n  filter(fn: any): any {\n    if (this.isSome() && fn(this._value)) {\n      return this;\n    } else {\n      return none();\n    }\n  }\n\n  getOrInsert(value: T): Option<T> {\n    if (this.isNone()) {\n      this._value = value;\n    }\n    return this;\n  }\n  getOrInsertWith(fn: () => T): Option<T> {\n    if (this.isNone()) {\n      this._value = fn();\n    }\n    return this;\n  }\n\n  take(): Option<T> {\n    if (this.isSome()) {\n      const value = this._value;\n      this._value = NULL_SECRET as any;\n      return some(value);\n    } else {\n      return none();\n    }\n  }\n  from(value?: T | null): Option<T> {\n    if (value != null) {\n      this._value = value;\n    } else {\n      this.clear();\n    }\n    return this;\n  }\n  replace(value: T): Option<T> {\n    this._value = value;\n    return this;\n  }\n  clear(): Option<T> {\n    this._value = NULL_SECRET as any;\n    return this;\n  }\n\n  fromResult<T, E>(result: Result<T, E>): Option<T> {\n    if (result.isOk()) {\n      return some(result.unwrap());\n    } else {\n      return none();\n    }\n  }\n\n  ifSome(fn: (value: T) => void, elseFn?: () => void): Option<T> {\n    if (this.isSome()) {\n      fn(this._value);\n    } else if (elseFn) {\n      elseFn();\n    }\n    return this;\n  }\n  ifNone(fn: () => void, elseFn?: (value: T) => void): Option<T> {\n    if (this.isNone()) {\n      fn();\n    } else if (elseFn) {\n      elseFn(this._value);\n    }\n    return this;\n  }\n\n  fromJSON(json: T | null): Option<T> {\n    return Option.from(json);\n  }\n  toJSON(): T | null {\n    return this.map(toJSON).unwrapOr(null as any);\n  }\n  toJS(): T | null {\n    return this.map(toJS).unwrapOr(null as any);\n  }\n}\n\nexport const some = <T>(value: T): Option<T> =>\n  new Option(CREATE_SECRET, value);\nexport const none = <T>(): Option<T> =>\n  new Option(CREATE_SECRET, NULL_SECRET as T);\n","import type { Option } from \"../option\";\nimport type { Filter, IFilterBooleanFn, IFilterPredicateFn } from \"./Filter\";\nimport type { ForEach, IForEachFn } from \"./ForEach\";\nimport type { IMapFn, Map } from \"./Map\";\nimport type { Merge } from \"./Merge\";\nimport type { Skip } from \"./Skip\";\nimport type { Step } from \"./Step\";\nimport type { Take } from \"./Take\";\nimport type { IToMapFn, ToMap } from \"./ToMap\";\nimport type { Unflatten, UnflattenFn } from \"./Unflatten\";\nimport type { Enumerate } from \"./Enumerate\";\nimport type { Peekable } from \"./Peekable\";\nimport { none, some } from \"../option\";\n\nexport class Iter<T>\n  implements\n    Iterable<T>,\n    Iterator<T, undefined, undefined>,\n    IterableIterator<T>\n{\n  protected _iter: Iterator<T>;\n  protected _index = 0;\n\n  constructor(iter: Iterator<T>) {\n    this._iter = iter;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this;\n  }\n\n  iter(): Iter<T> {\n    return this;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    return this._iter.next();\n  }\n\n  nextWithIndex(): IteratorResult<[T, number], undefined> {\n    const next = this._iter.next();\n\n    if (next.done) {\n      return next;\n    } else {\n      return { value: [next.value, this._index++] };\n    }\n  }\n\n  enumerate(): Enumerate<T>;\n  enumerate(): any {\n    return undefined;\n  }\n\n  peekable(): Peekable<T>;\n  peekable(): any {\n    return undefined;\n  }\n\n  forEach(fn: IForEachFn<T>): ForEach<T>;\n  forEach(_fn: any): any {\n    return undefined;\n  }\n\n  map<B>(fn: IMapFn<T, B>): Map<T, B>;\n  map(_fn: any): any {\n    return undefined;\n  }\n\n  merge(iter: Iterator<T>): Merge<T>;\n  merge(_iter: any): any {\n    return undefined;\n  }\n\n  concat(iter: Iterator<T>): Merge<T> {\n    return this.merge(iter);\n  }\n\n  filter<S extends T>(fn: IFilterPredicateFn<T, S>): Filter<T, S>;\n  filter(fn: IFilterBooleanFn<T>): Filter<T, T>;\n  filter(_fn: any): any {\n    return undefined;\n  }\n\n  step(step: number): Step<T>;\n  step(_step: any): any {\n    return undefined;\n  }\n\n  skip(skip: number): Skip<T>;\n  skip(_skip: any): any {\n    return undefined;\n  }\n\n  take(count: number): Take<T>;\n  take(_count: any): any {\n    return undefined;\n  }\n\n  toMap<K extends string | number | symbol, V>(\n    keyFn?: IToMapFn<T, K>,\n    valueFn?: IToMapFn<T, V>\n  ): ToMap<T, K, V>;\n  toMap(_keyFn: any, _valueFn: any): any {\n    return undefined;\n  }\n\n  count() {\n    return this.reduce(0, (count) => count + 1);\n  }\n\n  consume() {\n    let next = this.next();\n\n    while (!next.done) {\n      next = this.next();\n    }\n\n    return this;\n  }\n\n  toArray(): T[] {\n    return this.reduce<T[]>([], (array, value) => {\n      array.push(value);\n      return array;\n    });\n  }\n\n  join(separator?: string): string {\n    return this.toArray().join(separator);\n  }\n\n  indexOf(value: T): number {\n    let next = this.next(),\n      index = 0;\n\n    while (!next.done) {\n      if (next.value === value) {\n        return index;\n      }\n      index++;\n      next = this.next();\n    }\n\n    return -1;\n  }\n\n  findIndex(fn: (value: T, index: number) => boolean): number {\n    let next = this.nextWithIndex();\n\n    while (!next.done) {\n      const [value, index] = next.value;\n\n      if (fn(value, index)) {\n        return index;\n      }\n      next = this.nextWithIndex();\n    }\n\n    return -1;\n  }\n\n  find(fn: (value: T, index: number) => boolean): Option<T> {\n    let next = this.nextWithIndex();\n\n    while (!next.done) {\n      const [value, index] = next.value;\n\n      if (fn(value, index)) {\n        return some(value);\n      }\n      next = this.nextWithIndex();\n    }\n\n    return none();\n  }\n\n  findAll(fn: (value: T) => boolean) {\n    return this.filter(fn);\n  }\n\n  nth(index = 0): Option<T> {\n    let next = this.next();\n\n    if (index < 0) {\n      index = 0;\n    }\n\n    while (!next.done) {\n      if (index-- <= 0) {\n        return some(next.value);\n      }\n      next = this.next();\n    }\n\n    return none();\n  }\n\n  first(): Option<T> {\n    return this.nth(0);\n  }\n\n  last(): Option<T> {\n    let current = this.next();\n\n    while (!current.done) {\n      const next = this.next();\n\n      if (next.done) {\n        return some(current.value);\n      } else {\n        current = next;\n      }\n    }\n\n    return none();\n  }\n\n  any(fn: (value: T, index: number) => boolean): boolean {\n    return this.findIndex(fn) !== -1;\n  }\n  some(fn: (value: T, index: number) => boolean): boolean {\n    return this.any(fn);\n  }\n  none(fn: (value: T, index: number) => boolean): boolean {\n    return this.findIndex(fn) === -1;\n  }\n\n  all(fn: (value: T, index: number) => boolean): boolean {\n    let next = this.nextWithIndex();\n\n    while (!next.done) {\n      const [value, index] = next.value;\n\n      if (!fn(value, index)) {\n        return false;\n      }\n      next = this.nextWithIndex();\n    }\n\n    return true;\n  }\n\n  unflatten<U>(fn: UnflattenFn<T, U>): Unflatten<T, U>;\n  unflatten(_fn: any): any {\n    return undefined;\n  }\n\n  reduce<C>(acc: C, fn: (acc: C, value: T, index: number) => C): C {\n    let next = this.next();\n\n    while (!next.done) {\n      const value = next.value;\n      acc = fn(acc, value, this._index - 1);\n      next = this.next();\n    }\n\n    return acc;\n  }\n\n  reverse() {\n    return iter(this.toArray().reverse());\n  }\n}\n\nexport function iter<T>(\n  value: T[] | Iterator<T> | Iter<T> | Iterable<T>\n): Iter<T>;\nexport function iter<O>(\n  value: O | Iterable<[keyof O, O[keyof O]]>\n): Iter<[keyof O, O[keyof O]]>;\n\nexport function iter(value: any): Iter<any> {\n  if (value != null) {\n    if (typeof value[Symbol.iterator] === \"function\") {\n      return new Iter(value[Symbol.iterator]());\n    } else if (typeof value.next === \"function\") {\n      if (value instanceof Iter) {\n        return value;\n      } else {\n        return new Iter(value);\n      }\n    } else if (typeof value === \"object\") {\n      return iter(Object.entries(value));\n    } else {\n      return iter([value]);\n    }\n  } else {\n    return iter([] as any[]);\n  }\n}\n","import { Iter } from \"./Iter\";\n\nexport class Enumerate<T> extends Iter<[number, T]> {\n  constructor(iter: Iterator<T>) {\n    super(iter as any);\n  }\n\n  next(): IteratorResult<[number, T], undefined> {\n    const next: IteratorResult<[T, number], undefined> =\n      super.nextWithIndex() as any;\n\n    if (next.done) {\n      return next as any;\n    } else {\n      return { value: swap(next.value) };\n    }\n  }\n}\n\nIter.prototype.enumerate = function enumerate() {\n  return new Enumerate(this);\n};\n\nfunction swap<A, B>(array: [A, B]): [B, A] {\n  const tmp = array[0],\n    newArray: [B, A] = array as any;\n  newArray[0] = array[1];\n  newArray[1] = tmp;\n  return newArray;\n}\n","import { Iter } from \"./Iter\";\n\nexport type IFilterPredicateFn<T, S extends T> = (\n  value: T,\n  index: number\n) => value is S;\nexport type IFilterBooleanFn<T> = (value: T, index: number) => boolean;\n\nexport class Filter<T, S extends T> extends Iter<S> {\n  private _fn: IFilterBooleanFn<T> | IFilterPredicateFn<T, S>;\n\n  constructor(\n    iter: Iterator<T>,\n    fn: IFilterBooleanFn<T> | IFilterPredicateFn<T, S>\n  ) {\n    super(iter as any);\n    this._fn = fn;\n  }\n\n  next(): IteratorResult<S, undefined> {\n    let result = super.nextWithIndex();\n\n    while (!result.done) {\n      const [value, index] = result.value;\n\n      if (this._fn(value, index)) {\n        return { done: false, value };\n      }\n      result = super.nextWithIndex();\n    }\n\n    return { done: true, value: undefined };\n  }\n}\n\nIter.prototype.filter = function filter(fn: any): any {\n  return new Filter(this, fn);\n};\n","import { Iter } from \"./Iter\";\n\nexport type IForEachFn<T> = (value: T, index: number) => void;\n\nexport class ForEach<T> extends Iter<T> {\n  private _fn: (tuple: [value: T, index: number]) => T;\n\n  constructor(iter: Iterator<T>, fn: IForEachFn<T>) {\n    super(iter);\n    this._fn = ([value, index]) => {\n      fn(value, index);\n      return value;\n    };\n  }\n\n  next(): IteratorResult<T, undefined> {\n    const next = super.nextWithIndex();\n\n    if (next.done) {\n      return next;\n    } else {\n      return { done: false, value: this._fn(next.value) };\n    }\n  }\n}\n\nIter.prototype.forEach = function forEach(fn: any) {\n  return new ForEach(this, fn);\n};\n","import { Iter } from \"./Iter\";\n\nexport type IMapFn<A, B> = (value: A, index: number) => B;\n\nexport class Map<A, B> extends Iter<B> {\n  private _fn: (tuple: [value: A, index: number]) => B;\n\n  constructor(iter: Iterator<A>, fn: IMapFn<A, B>) {\n    super(iter as any as Iterator<B>);\n    this._fn = ([value, index]) => fn(value, index);\n  }\n\n  next(): IteratorResult<B, undefined> {\n    const next = super.nextWithIndex();\n\n    if (next.done) {\n      return next;\n    } else {\n      return { done: false, value: this._fn(next.value as any) };\n    }\n  }\n}\n\nIter.prototype.map = function map(fn: any) {\n  return new Map(this, fn);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Merge<T> extends Iter<T> {\n  private _other: Iterator<T>;\n\n  constructor(iter: Iterator<T>, other: Iterator<T>) {\n    super(iter);\n    this._other = other;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    const next = super.next();\n\n    if (next.done) {\n      return this._other.next();\n    } else {\n      return next;\n    }\n  }\n}\n\nIter.prototype.merge = function merge(other: any) {\n  return new Merge(this, other);\n};\n","import { Option, some, none } from \"../option\";\nimport { Iter } from \"./Iter\";\n\nexport class Peekable<T> extends Iter<T> {\n  private peeked: T[] = [];\n\n  unpeekAll() {\n    this.peeked.length = 0;\n    return this;\n  }\n\n  unpeek(): Option<T> {\n    if (this.peeked.length > 0) {\n      return some(this.peeked.shift() as T);\n    } else {\n      return none();\n    }\n  }\n\n  peek(offset = 0): Option<T> {\n    if (offset < this.peeked.length) {\n      return some(this.peeked[offset]);\n    } else {\n      let index = this.peeked.length - offset - 1,\n        next = super.next();\n\n      while (!next.done) {\n        this.peeked.push(next.value);\n\n        if (--index <= 0) {\n          break;\n        } else {\n          next = super.next();\n        }\n      }\n\n      if (next.done) {\n        return none();\n      } else {\n        return some(next.value);\n      }\n    }\n  }\n\n  next(): IteratorResult<T, undefined> {\n    const peeked = this.unpeek();\n\n    if (peeked.isSome()) {\n      return { done: false, value: peeked.unwrap() };\n    }\n\n    const next = super.next();\n\n    if (next.done) {\n      return next as any;\n    } else {\n      return { done: false, value: next.value };\n    }\n  }\n}\n\nIter.prototype.peekable = function peekable() {\n  return new Peekable(this);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Skip<T> extends Iter<T> {\n  private _skipped: number;\n  private _skip: number;\n\n  constructor(iter: Iterator<T>, skip: number) {\n    super(iter);\n    this._skipped = 0;\n    this._skip = (skip <= 0 ? 0 : skip) | 0;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    let result = super.next();\n\n    while (!result.done) {\n      if (this._skipped <= this._skip) {\n        this._skipped += 1;\n        result = super.next();\n      } else {\n        return result;\n      }\n    }\n\n    return { done: true, value: undefined };\n  }\n}\n\nIter.prototype.skip = function skip(skip: any) {\n  return new Skip(this, skip);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Step<T> extends Iter<T> {\n  private _stepped: number;\n  private _step: number;\n\n  constructor(iter: Iterator<T>, step: number) {\n    super(iter);\n    this._stepped = 0;\n    this._step = step <= 0 ? 1 : step | 0;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    let result = super.next();\n\n    while (!result.done) {\n      if (this._stepped < this._step) {\n        this._stepped += 1;\n        result = super.next();\n      } else {\n        this._stepped = 0;\n        return result;\n      }\n    }\n\n    return { done: true, value: undefined };\n  }\n}\n\nIter.prototype.step = function step(step: any) {\n  return new Step(this, step);\n};\n","import { Iter } from \"./Iter\";\n\nexport class Take<T> extends Iter<T> {\n  private _taken: number;\n  private _count: number;\n\n  constructor(iter: Iterator<T>, count: number) {\n    super(iter);\n    this._taken = 0;\n    this._count = (count <= 0 ? 0 : count) | 0;\n  }\n\n  next(): IteratorResult<T, undefined> {\n    if (this._taken < this._count) {\n      this._taken += 1;\n      return super.next();\n    } else {\n      return { done: true, value: undefined };\n    }\n  }\n}\n\nIter.prototype.take = function take(count: any) {\n  return new Take(this, count);\n};\n","import { Iter } from \"./Iter\";\n\nexport type IToMapFn<A, B> = (value: A, index: number) => B;\n\nconst defaultKeyFn = <A, B>(key: A): B => key as any;\nconst defaultValueFn = <A, B>(value: A): B => value as any;\n\nexport class ToMap<T, K extends string | number | symbol, V> extends Iter<\n  [K, V]\n> {\n  private _map: (tuple: [value: any, index: number]) => [K, V];\n\n  constructor(\n    iter: Iterator<T>,\n    keyFn: IToMapFn<T, K> = defaultKeyFn,\n    valueFn: IToMapFn<T, V> = defaultValueFn\n  ) {\n    super(iter as any as Iterator<[K, V]>);\n    this._map = ([value, index]) =>\n      [keyFn(value, index), valueFn(value, index)] as [K, V];\n  }\n\n  toObject(): Record<K, V> {\n    return this.reduce<Record<K, V>>({} as Record<K, V>, (object, value) => {\n      object[value[0]] = value[1];\n      return object;\n    });\n  }\n\n  next(): IteratorResult<[K, V], undefined> {\n    const next = super.nextWithIndex();\n\n    if (next.done) {\n      return next as any;\n    } else {\n      return { done: false, value: this._map(next.value) };\n    }\n  }\n}\n\nIter.prototype.toMap = function toMap(keyFn: any, valueFn: any) {\n  return new ToMap(this, keyFn, valueFn);\n};\n","import { Iter } from \"./Iter\";\n\nexport type UnflattenFn<T, U> = (iter: Iterator<T>) => IteratorResult<U>;\n\nexport class Unflatten<T, U> extends Iter<U> {\n  private _fn: UnflattenFn<T, U>;\n\n  constructor(iter: Iterator<T>, fn: UnflattenFn<T, U>) {\n    super(iter as any);\n    this._fn = fn;\n  }\n\n  next(): IteratorResult<U> {\n    return this._fn(this._iter as any);\n  }\n}\n\nIter.prototype.unflatten = function unflatten(fn: any) {\n  return new Unflatten(this, fn);\n};\n","import { Iter } from \"../iter\";\n\nexport enum RangeDirection {\n  Forward,\n  Backward,\n}\n\nexport class Range implements Iterator<number>, Iterable<number> {\n  static from(start: number, end: number, step = 1) {\n    return new Range(start, end, step);\n  }\n\n  private start: number;\n  private end: number;\n  private step: number;\n  private direction: RangeDirection;\n\n  constructor(start: number, end: number, step = 1) {\n    this.start = start;\n    this.end = end;\n    this.step = Math.abs(step);\n    this.direction =\n      start > end ? RangeDirection.Backward : RangeDirection.Forward;\n  }\n\n  getStart() {\n    return this.start;\n  }\n  getEnd() {\n    return this.end;\n  }\n  getStep() {\n    return this.step;\n  }\n  getDirection() {\n    return this.direction;\n  }\n\n  contains(item: number) {\n    return this.start <= item && item <= this.end;\n  }\n\n  isEmpty() {\n    if (this.direction === RangeDirection.Forward) {\n      return this.start > this.end;\n    } else {\n      return this.start < this.end;\n    }\n  }\n\n  iter(): Iter<number> {\n    return new Iter(this);\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  next(): IteratorResult<number> {\n    if (this.isEmpty()) {\n      return { done: true, value: undefined };\n    } else {\n      const value = this.start;\n      if (this.direction === RangeDirection.Forward) {\n        this.start += this.step;\n      } else {\n        this.start -= this.step;\n      }\n      return { done: false, value };\n    }\n  }\n}\n\nexport const range = Range.from;\n","import { Range, RangeDirection } from \"./Range\";\n\nexport class RangeFrom extends Range {\n  static from(\n    start: number,\n    direction: RangeDirection = RangeDirection.Forward,\n    step = 1\n  ) {\n    return new RangeFrom(start, direction, step);\n  }\n\n  constructor(\n    start: number,\n    direction: RangeDirection = RangeDirection.Forward,\n    step = 1\n  ) {\n    if (direction === RangeDirection.Forward) {\n      super(start, Infinity, step);\n    } else {\n      super(start, -Infinity, step);\n    }\n  }\n}\n\nexport const rangeFrom = RangeFrom.from;\n","import type { Option } from \"../option\";\nimport { toJS } from \"../toJS\";\nimport { toJSON } from \"../toJSON\";\n\nconst CREATE_SECRET = {},\n  NULL_SECRET = {};\n\nexport class Result<T, E = Error> {\n  static ok<T, E = Error>(value: T): Result<T, E> {\n    return ok(value);\n  }\n  static err<T, E = Error>(error: E): Result<T, E> {\n    return err(error);\n  }\n  static fromOption<T>(\n    option: Option<T>,\n    msg = \"Tried to create Result from none Option\"\n  ): Result<T, Error> {\n    if (option.isSome()) {\n      return ok(option.unwrap());\n    } else {\n      return err<T>(new Error(msg));\n    }\n  }\n\n  private _ok: T;\n  private _err: E;\n\n  constructor(createSecret: unknown, ok: T, err: E) {\n    if (createSecret !== CREATE_SECRET) {\n      throw new TypeError(\n        \"Results can only be created with the ok or err functions\"\n      );\n    }\n    this._ok = ok;\n    this._err = err;\n  }\n\n  isErr(): boolean {\n    return this._err !== NULL_SECRET;\n  }\n\n  isOk(): boolean {\n    return this._ok !== NULL_SECRET;\n  }\n\n  expect(): T {\n    if (this.isOk()) {\n      return this._ok;\n    } else {\n      throw this._err;\n    }\n  }\n\n  unwrap(): T {\n    return this.expect();\n  }\n  unwrapOr(def: T): T {\n    if (this.isOk()) {\n      return this._ok;\n    } else {\n      return def;\n    }\n  }\n  unwrapOrElse(defFn: (error: E) => T): T {\n    if (this.isOk()) {\n      return this._ok;\n    } else {\n      return defFn(this._err);\n    }\n  }\n\n  map<U>(fn: (ok: T) => U): Result<U, E> {\n    if (this.isOk()) {\n      return ok(fn(this._ok));\n    } else {\n      return err(this._err);\n    }\n  }\n  mapOr<U>(fn: (ok: T) => U, def: U): Result<U, E> {\n    if (this.isOk()) {\n      return ok(fn(this._ok));\n    } else {\n      return ok(def);\n    }\n  }\n  mapOrElse<U>(fn: (ok: T) => U, defFn: (error: E) => U): Result<U, E> {\n    if (this.isOk()) {\n      return ok(fn(this._ok));\n    } else {\n      return ok(defFn(this._err));\n    }\n  }\n\n  flatMap<U>(fn: (ok: T) => Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return err(this._err);\n    }\n  }\n  flatMapOr<U>(fn: (ok: T) => Result<U, E>, def: Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return def;\n    }\n  }\n  flatMapOrElse<U>(\n    fn: (ok: T) => Result<U, E>,\n    defFn: (error: E) => Result<U, E>\n  ): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return defFn(this._err);\n    }\n  }\n\n  expectErr(msg: (() => string) | string): E {\n    if (this.isErr()) {\n      return this._err;\n    } else {\n      throw new Error(typeof msg === \"function\" ? msg() : msg);\n    }\n  }\n\n  unwrapErr(): E {\n    return this.expectErr(\"Tried to unwrap error value of ok Result\");\n  }\n  unwrapErrOr(def: E): E {\n    if (this.isErr()) {\n      return this._err;\n    } else {\n      return def;\n    }\n  }\n  unwrapErrOrElse(defFn: (value: T) => E): E {\n    if (this.isErr()) {\n      return this._err;\n    } else {\n      return defFn(this._ok);\n    }\n  }\n\n  mapErr<U>(fn: (err: E) => U): Result<T, U> {\n    if (this.isErr()) {\n      return err(fn(this._err));\n    } else {\n      return ok(this._ok);\n    }\n  }\n  mapErrOr<U>(fn: (err: E) => U, def: U): Result<T, U> {\n    if (this.isErr()) {\n      return err(fn(this._err));\n    } else {\n      return err(def);\n    }\n  }\n  mapErrOrElse<U>(fn: (err: E) => U, defFn: (value: T) => U): Result<T, U> {\n    if (this.isErr()) {\n      return err(fn(this._err));\n    } else {\n      return err(defFn(this._ok));\n    }\n  }\n\n  flatMapErr<U>(fn: (err: E) => Result<T, U>): Result<T, U> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return ok(this._ok);\n    }\n  }\n  flatMapErrOr<U>(\n    fn: (err: E) => Result<T, U>,\n    def: Result<T, U>\n  ): Result<T, U> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return def;\n    }\n  }\n  flatMapErrOrElse<U>(\n    fn: (err: E) => Result<T, U>,\n    defFn: (value: T) => Result<T, U>\n  ): Result<T, U> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return defFn(this._ok);\n    }\n  }\n\n  and<U>(ok: Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return ok;\n    } else {\n      return err(this._err);\n    }\n  }\n  andThen<U>(fn: (value: T) => Result<U, E>): Result<U, E> {\n    if (this.isOk()) {\n      return fn(this._ok);\n    } else {\n      return err(this._err);\n    }\n  }\n\n  or(ok: Result<T, E>): Result<T, E> {\n    if (this.isErr()) {\n      return ok;\n    } else {\n      return this;\n    }\n  }\n  orElse(fn: (error: E) => Result<T, E>): Result<T, E> {\n    if (this.isErr()) {\n      return fn(this._err);\n    } else {\n      return this;\n    }\n  }\n\n  ifOk(fn: (ok: T) => void, errFn?: (err: E) => void): Result<T, E> {\n    if (this.isOk()) {\n      fn(this._ok);\n    } else if (errFn) {\n      errFn(this._err);\n    }\n    return this;\n  }\n  ifErr(fn: (err: E) => void, okFn?: (ok: T) => void): Result<T, E> {\n    if (this.isErr()) {\n      fn(this._err);\n    } else if (okFn) {\n      okFn(this._ok);\n    }\n    return this;\n  }\n\n  fromJSON(json: any): Result<T, E> {\n    if (json) {\n      if (json.ok) {\n        return ok(json.ok);\n      } else if (json.err) {\n        return err(json.err);\n      }\n    }\n    throw new TypeError(\"Invalid json for Result\");\n  }\n  toJSON(): IResultOk<T> | IResultErr<E> {\n    if (this.isOk()) {\n      return {\n        ok: this.map(toJSON).unwrap(),\n      };\n    } else {\n      return {\n        err: this.mapErr(toJSON).unwrapErr(),\n      };\n    }\n  }\n  toJS(): IResultOk<T> | IResultErr<E> {\n    if (this.isOk()) {\n      return {\n        ok: this.map(toJS).unwrap(),\n      };\n    } else {\n      return {\n        err: this.mapErr(toJS).unwrapErr(),\n      };\n    }\n  }\n}\n\nexport interface IResultOk<T> {\n  ok: T;\n}\nexport interface IResultErr<E> {\n  err: E;\n}\n\nexport const ok = <T, E = Error>(value: T): Result<T, E> =>\n  new Result(CREATE_SECRET, value, NULL_SECRET as E);\nexport const err = <T, E = Error>(error: E): Result<T, E> =>\n  new Result(CREATE_SECRET, NULL_SECRET as T, error);\n"],"names":["integerToBytes","bytes","integer","BYTE_ARRAY","Uint8Array","INTEGER_ARRAY","Hasher","writeByte","byte","this","write","writeInteger","FastHasher","constructor","finish","hash","i","il","length","i32","defaultHasher","bytesToInteger","ALREADY_HASHED_SET","Set","hashOf","value","getHasher","hasher","hashInternal","clear","has","add","hashString","hashNumber","hashBoolean","toString","hashSymbol","Symbol","iterator","iterable","hashIterable","array","hashArray","key","hasOwnProperty","hashObject","char","charCodeAt","toJS","toJSON","CREATE_SECRET","NULL_SECRET","Option","createSecret","TypeError","_value","some","none","from","fromResult","result","isOk","unwrap","isNone","isSome","expect","msg","Error","unwrapOr","def","unwrapOrElse","defFn","map","fn","mapOr","mapOrElse","flatMap","flatMapOr","flatMapOrElse","and","andThen","or","orElse","xor","a","b","filter","getOrInsert","getOrInsertWith","take","replace","ifSome","elseFn","ifNone","fromJSON","json","Iter","iter","_iter","next","nextWithIndex","done","_index","enumerate","peekable","forEach","_fn","merge","concat","step","_step","skip","_skip","_count","toMap","_keyFn","_valueFn","count","reduce","consume","toArray","push","join","separator","indexOf","index","findIndex","find","findAll","nth","first","last","current","any","all","unflatten","acc","reverse","Object","entries","Enumerate","super","swap","tmp","newArray","prototype","Filter","undefined","ForEach","Map","Merge","other","_other","Peekable","unpeekAll","peeked","unpeek","shift","peek","offset","Skip","_skipped","Step","_stepped","Take","_taken","defaultKeyFn","defaultValueFn","ToMap","keyFn","valueFn","_map","toObject","object","Unflatten","RangeDirection","Range","start","end","Math","abs","direction","Backward","Forward","getStart","getEnd","getStep","getDirection","contains","item","isEmpty","range","RangeFrom","Infinity","rangeFrom","Result","ok","err","_ok","_err","error","fromOption","option","isErr","expectErr","unwrapErr","unwrapErrOr","unwrapErrOrElse","mapErr","mapErrOr","mapErrOrElse","flatMapErr","flatMapErrOr","flatMapErrOrElse","ifOk","errFn","ifErr","okFn"],"mappings":"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"}